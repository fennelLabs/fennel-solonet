---
name: Build and Publish Fennel Node

# Configures this workflow to run every time a change is pushed to main.
on:
  push:
    branches: ['main']

# Defines custom environment variables for the workflow.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # Centralized bootnode configuration
  EXTERNAL_BOOTNODES: |
    [
      "/dns4/bootnode1.fennel.network/tcp/30333/p2p/12D3KooWDCZGrnJhsgWJtDcs6eZc1hUBrVj5QqkEWggAkNVowRAi",
      "/dns4/bootnode2.fennel.network/tcp/30333/p2p/12D3KooWDbfFv6oepAXmQaiwFaVjD9g7AxowQ8LQdWTcVYpKhnAx"
    ]
  INTERNAL_BOOTNODES: |
    [
      "/dns4/fennel-bootnode-1.fennel-staging.svc.cluster.local/tcp/30333/p2p/12D3KooWDCZGrnJhsgWJtDcs6eZc1hUBrVj5QqkEWggAkNVowRAi",
      "/dns4/fennel-bootnode-2.fennel-staging.svc.cluster.local/tcp/30333/p2p/12D3KooWDbfFv6oepAXmQaiwFaVjD9g7AxowQ8LQdWTcVYpKhnAx"
    ]

# Multiple jobs workflow for parallel execution
jobs:
  # Job 1: Build deterministic runtime with srtool
  build-runtime:
    runs-on: ubuntu-latest
    outputs:
      wasm-hash: ${{ steps.wasm.outputs.hash }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          # Cache key based on Cargo.lock and source files
          key: ${{ hashFiles('**/Cargo.lock') }}-${{ hashFiles('**/*.rs') }}
          # Cache the target directory and Cargo registry
          cache-targets: true
          cache-directories: |
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/

      # Build the runtime deterministically with srtool and capture
      # its SHA-256 so we can inject it as an OCI label.
      - name: Build runtime with srtool & extract Wasm hash
        id: wasm
        run: |
          set -euo pipefail
          echo "ðŸ› ï¸  Running srtool to build compact runtimeâ€¦"
          # Build runtime inside srtool container
          docker run --rm \
            -v "${PWD}":/build \
            -e RUNTIME_DIR=runtime/fennel \
            -e PACKAGE=fennel-node-runtime \
            --workdir /build \
            paritytech/srtool:1.84.1 /srtool/build

          # After the container exits the compiled Wasm lives in mounted volume
          WASM_FILE="runtime/fennel/target/srtool/release/wbuild/fennel-node-runtime/fennel_node_runtime.compact.wasm"
          HASH=$(sha256sum "$WASM_FILE" | awk '{print "0x"$1}')
          echo "hash=$HASH" >> $GITHUB_OUTPUT
          echo "âœ… Deterministic Wasm hash: $HASH"

      - name: Upload runtime artifact
        uses: actions/upload-artifact@v4
        with:
          name: fennel-runtime
          path: >-
            runtime/fennel/target/srtool/release/wbuild/fennel-node-runtime/fennel_node_runtime.compact.wasm
          retention-days: 1

  # Job 2: Generate chain specifications (depends on runtime)
  generate-chainspecs:
    runs-on: ubuntu-latest
    needs: build-runtime
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # Download runtime artifact
      - name: Download runtime artifact
        uses: actions/download-artifact@v4
        with:
          name: fennel-runtime
          path: >-
            runtime/fennel/target/srtool/release/wbuild/fennel-node-runtime/

      - name: Cache chain-spec-builder
        uses: actions/cache@v4
        with:
          path: ~/.cargo/bin/chain-spec-builder
          key: >-
            ${{ runner.os }}-chain-spec-builder-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-chain-spec-builder-

      - name: Install dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          mkdir -p "${HOME}/.cargo/bin"

          docker run --rm \
            -v "${PWD}":/build \
            -v "${HOME}/.cargo/bin":/cargo-bin \
            --workdir /build \
            paritytech/ci-unified:latest \
            bash -c "
              cargo install staging-chain-spec-builder --locked \
                --root /tmp/cargo-install && \
              cp /tmp/cargo-install/bin/chain-spec-builder /cargo-bin/
            "
          echo "${HOME}/.cargo/bin" >> $GITHUB_PATH

      - name: Generate development chain specs
        run: |
          set -euo pipefail
          mkdir -p chainspecs/development

          WASM_FILE="runtime/fennel/target/srtool/release/wbuild/fennel-node-runtime/fennel_node_runtime.compact.wasm"
          chain-spec-builder \
            -c chainspecs/development/development.json \
            create \
            -r "$WASM_FILE" \
            named-preset development

          chain-spec-builder \
            -c chainspecs/development/development-raw.json \
            convert-to-raw \
            chainspecs/development/development.json

      - name: Generate staging chain specs
        run: |
          set -euo pipefail
          mkdir -p chainspecs/staging

          WASM_FILE="runtime/fennel/target/srtool/release/wbuild/fennel-node-runtime/fennel_node_runtime.compact.wasm"
          chain-spec-builder \
            -c chainspecs/staging/staging-chainspec.json \
            create \
            -r "$WASM_FILE" \
            named-preset staging

          chain-spec-builder \
            -c chainspecs/staging/staging-raw.json \
            convert-to-raw \
            chainspecs/staging/staging-chainspec.json

      - name: Inject bootnodes
        run: |
          set -euo pipefail

          # Function to inject bootnodes
          inject_bootnodes() {
            local spec_file=$1
            local target=$2

            ALL_BOOTNODES=$(jq -c -n \
              --argjson ext "$EXTERNAL_BOOTNODES" \
              --argjson int "$INTERNAL_BOOTNODES" \
              '$ext + $int')

            CURRENT_BOOTNODES=$(jq -c '.bootNodes // []' "$spec_file")
            if [ "$CURRENT_BOOTNODES" != "$ALL_BOOTNODES" ]; then
              echo "ðŸ“ Updating bootNodes in ${target} chain spec..."
              jq --argjson arr "$ALL_BOOTNODES" \
                '.bootNodes = $arr' "$spec_file" > tmp.json && \
                mv tmp.json "$spec_file"

                              # Regenerate raw spec
                local raw_file="${spec_file%-chainspec.json}-raw.json"
                [ "$target" = "development" ] && \
                  raw_file="${spec_file%.json}-raw.json"

                              chain-spec-builder -c "$raw_file" convert-to-raw \
                  "$spec_file"
              echo "âœ… Bootnodes updated for $target"
            else
              echo "âœ… No changes needed for $target bootnodes"
            fi
          }

          inject_bootnodes \
            "chainspecs/development/development.json" "development"
          inject_bootnodes \
            "chainspecs/staging/staging-chainspec.json" "staging"

      - name: Commit chain specs
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add chainspecs/

          if ! git diff --staged --quiet; then
            git commit -m "Update chain specs with bootnodes [ci skip]"
            git push origin ${GITHUB_REF#refs/heads/}
            echo "âœ… Chain specs committed and pushed"
          else
            echo "No changes to chain specs"
          fi

      - name: Upload chain specs artifact
        uses: actions/upload-artifact@v4
        with:
          name: fennel-chainspecs
          path: |
            chainspecs/development/
            chainspecs/staging/
          retention-days: 30

  # Job 3: Build and push Docker image (depends on runtime)
  build-docker:
    runs-on: ubuntu-latest
    needs: build-runtime
    permissions:
      contents: read
      packages: write
    outputs:
      image-tags: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      sha-tag: ${{ steps.extract-tag.outputs.tag }}
    steps:
      - name: Free up disk space
        run: |
          echo "ðŸ§¹ Freeing up disk space..."
          df -h
          
          # Remove unnecessary packages and files
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo rm -rf /usr/local/share/boost
          sudo rm -rf /usr/lib/jvm
          sudo rm -rf /usr/share/swift
          
          # Clean package caches
          sudo apt-get clean
          sudo apt-get autoremove -y
          
          # Clean Docker system
          docker system prune -af --volumes
          
          echo "ðŸŽ¯ Disk space after cleanup:"
          df -h

      - name: Checkout repository
        uses: actions/checkout@v4

      # Download runtime artifact
      - name: Download runtime artifact
        uses: actions/download-artifact@v4
        with:
          name: fennel-runtime
          path: >-
            runtime/fennel/target/srtool/release/wbuild/fennel-node-runtime/

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          # Enable advanced BuildKit features
          driver-opts: |
            network=host
          buildkitd-flags: |
            --allow-insecure-entitlement=network.host
            --allow-insecure-entitlement=security.insecure

      - name: Log in to Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create lowercase repository name for cache
        id: repo-name
        run: |
          REPO_LOWER=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')
          echo "cache-repo=$REPO_LOWER" >> $GITHUB_OUTPUT

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,format=long

      - name: Extract SHA tag for outputs
        id: extract-tag
        run: |
          # Extract the sha-prefixed tag from metadata output
          SHA_TAG=$(echo '${{ steps.meta.outputs.tags }}' | \
            grep -o 'sha-[a-f0-9]*' | head -1)
          echo "tag=$SHA_TAG" >> $GITHUB_OUTPUT
          echo "Extracted SHA tag: $SHA_TAG"

      - name: Check disk space before build
        run: |
          echo "ðŸ’¾ Disk space before Docker build:"
          df -h
          echo "ðŸ—‚ï¸  Docker system info:"
          docker system df

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            WASM_HASH=${{ needs.build-runtime.outputs.wasm-hash }}
          # Advanced BuildKit cache configuration
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ steps.repo-name.outputs.cache-repo }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ steps.repo-name.outputs.cache-repo }}:buildcache,mode=max
            type=inline
          # Performance optimizations
          provenance: false
          sbom: false
          # Enable advanced BuildKit features for better caching
          platforms: linux/amd64
          # Add shared memory size for large builds
          shm-size: 2g

      # Create and upload artifact containing image info
      - name: Output image info to artifact
        run: |
          mkdir -p ./artifacts
          echo "Image name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" > ./artifacts/image-info.txt
          echo "Tags:      ${{ steps.meta.outputs.tags }}" >> ./artifacts/image-info.txt
          echo "Wasm hash: ${{ needs.build-runtime.outputs.wasm-hash }}" >> ./artifacts/image-info.txt
          echo "Digest:    ${{ steps.build.outputs.digest }}" >> ./artifacts/image-info.txt
          echo "Created:   $(date -u +\"%Y-%m-%dT%H:%M:%SZ\")" >> \
            ./artifacts/image-info.txt

      - name: Upload Docker image info artifact
        uses: actions/upload-artifact@v4
        with:
          name: fennel-node-image-info
          path: ./artifacts/image-info.txt
          retention-days: 30

      - name: Clean up after build
        if: always()
        run: |
          echo "ðŸ§¹ Final cleanup..."
          docker system prune -af --volumes
          echo "ðŸ’¾ Final disk space:"
          df -h

  # Job 4: Lint Helm chart (can run in parallel with build jobs)
  lint-helm:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Cache Helm dependencies
        uses: actions/cache@v4
        with:
          path: Charts/fennel-node/charts
          key: >-
            ${{ runner.os }}-helm-${{ hashFiles('Charts/fennel-node/Chart.lock') }}
          restore-keys: |
            ${{ runner.os }}-helm-

      - name: Add Parity Helm repo
        run: |
          helm repo add parity https://paritytech.github.io/helm-charts
          helm repo update

      - name: Update Helm dependencies
        run: |
          cd Charts/fennel-node
          helm dependency update

      - name: Lint Helm chart
        run: |
          echo "ðŸ” Linting base chart..."
          helm lint Charts/fennel-node

          echo "ðŸ” Linting with staging values..."
          helm lint Charts/fennel-node \
            -f Charts/fennel-node/values-staging.yaml

  # Job 5: Package and publish Helm chart (depends on docker build and lint)
  publish-helm:
    runs-on: ubuntu-latest
    needs: [build-docker, lint-helm]
    permissions:
      contents: write
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      - name: Cache Helm dependencies
        uses: actions/cache@v4
        with:
          path: Charts/fennel-node/charts
          key: >-
            ${{ runner.os }}-helm-${{ hashFiles('Charts/fennel-node/Chart.lock') }}
          restore-keys: |
            ${{ runner.os }}-helm-

      - name: Add Parity Helm repo
        run: |
          helm repo add parity https://paritytech.github.io/helm-charts
          helm repo update

      - name: Update Helm dependencies
        run: |
          cd Charts/fennel-node
          helm dependency update

      - name: Update image tags in values files
        uses: fjogeleit/yaml-update-action@v0.13.2
        with:
          valueFile: 'Charts/fennel-node/values.yaml'
          propertyPath: 'image.tag'
          value: ${{ needs.build-docker.outputs.sha-tag }}
          commitChange: false

      - name: Update staging values file
        uses: fjogeleit/yaml-update-action@v0.13.2
        with:
          valueFile: 'Charts/fennel-node/values-staging.yaml'
          propertyPath: 'image.tag'
          value: ${{ needs.build-docker.outputs.sha-tag }}
          commitChange: false

      - name: Package Helm chart
        run: |
          mkdir -p release
          helm package Charts/fennel-node --destination release
          echo "ðŸ“¦ Packaged chart:"
          ls -la release/

      - name: Configure Git for chart release
        run: |
          git config user.name "$GITHUB_ACTOR"
          git config user.email \
            "$GITHUB_ACTOR@users.noreply.github.com"

      - name: Run chart-releaser
        uses: helm/chart-releaser-action@v1.6.0
        with:
          charts_dir: Charts
          skip_existing: true
        env:
          CR_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      - name: Upload Helm chart artifact
        uses: actions/upload-artifact@v4
        with:
          name: fennel-helm-chart
          path: release/*.tgz
          retention-days: 30

  # Job 6: Generate final workflow summary (depends on all jobs)
  summary:
    runs-on: ubuntu-latest
    needs: [build-runtime, generate-chainspecs, build-docker, publish-helm]
    if: always()
    steps:
      - name: Generate workflow summary
        run: |
          echo "## ðŸ“Š Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ› ï¸ Runtime Build" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.build-runtime.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Wasm Hash**: \`${{ needs.build-runtime.outputs.wasm-hash }}\`" >> \
            $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“‹ Chain Specs" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.generate-chainspecs.result }}" >> \
            $GITHUB_STEP_SUMMARY
          echo "- âœ… Development and staging specs generated" >> \
            $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ³ Docker Image" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.build-docker.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}\`" >> \
            $GITHUB_STEP_SUMMARY
          echo "- **Tag**: \`${{ needs.build-docker.outputs.sha-tag }}\`" >> \
            $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ“¦ Helm Chart" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ needs.publish-helm.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… Chart packaged and published to GitHub Pages" >> \
            $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸŽ¯ Overall Status" >> $GITHUB_STEP_SUMMARY
          if [[ "${{ needs.build-runtime.result }}" == "success" && \
                "${{ needs.generate-chainspecs.result }}" == "success" && \
                "${{ needs.build-docker.result }}" == "success" && \
                "${{ needs.publish-helm.result }}" == "success" ]]; then
            echo "âœ… **All jobs completed successfully!**" >> \
              $GITHUB_STEP_SUMMARY
          else
            echo "âŒ **Some jobs failed. Check individual job logs.**" >> \
              $GITHUB_STEP_SUMMARY
          fi
